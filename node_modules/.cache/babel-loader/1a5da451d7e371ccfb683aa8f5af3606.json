{"ast":null,"code":"import _objectSpread from\"C:/Users/Nick/OneDrive/Documents/github/reactcalculator/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _slicedToArray from\"C:/Users/Nick/OneDrive/Documents/github/reactcalculator/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";//this is a basic calculator making use of react.\n//inspiration and logical choices made following https://github.com/WebDevSimplified/react-calculator/blob/main/src/App.js\n//comments added by me, after building; the goal in this is to show understanding of what is going on, with a separate project to create a proper react.js app\nimport{useReducer}from'react';import DigitButton from\"./DigitButton\";import OperationButton from\"./OperationButton\";import'./App.css';import{jsxs as _jsxs}from\"react/jsx-runtime\";import{jsx as _jsx}from\"react/jsx-runtime\";export var ACTIONS={ADD_DIGIT:'add-digit',CLEAR:'clear',CHOOSE_OPERATION:'choose-operation',DELETE_DIGIT:'delete-digit',EVALUATE:'evaluate'};var INTEGER_FORMATTER=new Intl.NumberFormat(\"en-us\",{maximumFractionDigits:0});//the main compiler. the return is the output of the html\nfunction App(){var _useReducer=useReducer(reducer,{}),_useReducer2=_slicedToArray(_useReducer,2),_useReducer2$=_useReducer2[0],currentOperand=_useReducer2$.currentOperand,previousOperand=_useReducer2$.previousOperand,operation=_useReducer2$.operation,dispatch=_useReducer2[1];return/*#__PURE__*/_jsxs(\"div\",{className:\"calculator-grid\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"output\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"previous-operand\",children:[formatOperand(previousOperand),\" \",operation]}),/*#__PURE__*/_jsx(\"div\",{className:\"current-operand\",children:formatOperand(currentOperand)})]}),/*#__PURE__*/_jsx(\"button\",{className:\"span-two\",onClick:function onClick(){return dispatch({type:ACTIONS.CLEAR});},children:\"AC\"}),/*#__PURE__*/_jsx(\"button\",{onClick:function onClick(){return dispatch({type:ACTIONS.DELETE_DIGIT});},children:\"DEL\"}),/*#__PURE__*/_jsx(OperationButton,{operation:\"\\xF7\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"1\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"2\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"3\",dispatch:dispatch}),/*#__PURE__*/_jsx(OperationButton,{operation:\"*\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"4\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"5\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"6\",dispatch:dispatch}),/*#__PURE__*/_jsx(OperationButton,{operation:\"+\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"7\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"8\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"9\",dispatch:dispatch}),/*#__PURE__*/_jsx(OperationButton,{operation:\"-\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\".\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"0\",dispatch:dispatch}),/*#__PURE__*/_jsx(\"button\",{className:\"span-two\",onClick:function onClick(){return dispatch({type:ACTIONS.EVALUATE});},children:\"=\"})]});}//this receives any button press. the main switch statement bases off of the type that is passed\nfunction reducer(state,_ref){var type=_ref.type,payload=_ref.payload;switch(type){case ACTIONS.DELETE_DIGIT://on delete, overwrite the last operand if it is populated, or the last character in our evaluation string if it exists\nif(state.overwrite){return _objectSpread(_objectSpread({},state),{},{overwrite:false,currentOperand:null});}if(state.currentOperand==null)return state;if(state.currentOperand.length===1){return _objectSpread(_objectSpread({},state),{},{currentOperand:null});}return _objectSpread(_objectSpread({},state),{},{currentOperand:state.currentOperand.slice(0,-1)});//on add, append the digit to our evaluation string. if we want to add a decimal, and a decimal already exists, don't add it. \ncase ACTIONS.ADD_DIGIT:if(state.overwrite){return _objectSpread(_objectSpread({},state),{},{currentOperand:payload.digit,overwrite:false});}if(payload.digit===\"0\"&&state.currentOperand===\"0\")return state;if(payload.digit===\".\"&&state.currentOperand.includes(\".\"))return state;return _objectSpread(_objectSpread({},state),{},{currentOperand:\"\".concat(state.currentOperand||\"\").concat(payload.digit)});// simply clear our evaluation string\ncase ACTIONS.CLEAR:return{};//apply an operation to our evaluatable strings.\ncase ACTIONS.CHOOSE_OPERATION://if nothing exists yet, do nothing; return the state we started with\nif(state.currentOperand==null&&state.previousOperand==null){return state;}// if we already applied an operation, which is stored in previousOperand, replace the operation. we can't apply two operations on top of eachother\nif(state.currentOperand==null){return _objectSpread(_objectSpread({},state),{},{operation:payload.operation});}//if there is no previous operand, set the current operand to the previous operand and set the operation, clearing the current operand\nif(state.previousOperand==null){return _objectSpread(_objectSpread({},state),{},{operation:payload.operation,previousOperand:state.currentOperand,currentOperand:null});}// we have a current operand, a previous operand, and an operation. evaluate it and set the overwrite so the next input takes priority\nreturn _objectSpread(_objectSpread({},state),{},{previousOperand:evaluate(state),currentOperand:null,operation:payload.operation});// on evaluation, if we are missing a relevant section of info, do nothing.\n//if we have everything, set the current main display with the evaluation function. \n//overwrite is set to true, so if you input new information after evaluating, the new information takes priority.\ncase ACTIONS.EVALUATE:if(state.operation==null||state.currentOperand==null||state.previousOperand==null){return state;}return _objectSpread(_objectSpread({},state),{},{overwrite:true,previousOperand:null,operation:null,currentOperand:evaluate(state)});// do nothing on default, we should always have a type assigned on dispatch\ndefault:return state;}}//function which evaluates all of our inputs when we have a full math problem\nfunction evaluate(_ref2){var currentOperand=_ref2.currentOperand,previousOperand=_ref2.previousOperand,operation=_ref2.operation;//format our information as numerals so we can do math\nvar prev=parseFloat(previousOperand);var current=parseFloat(currentOperand);if(isNaN(prev)||isNaN(current))return\"\";var computation=\"\";//switch statement moves between our available mathematical operations\nswitch(operation){case\"+\":computation=prev+current;break;case\"-\":computation=prev-current;break;case\"*\":computation=prev*current;break;case\"รท\":computation=prev/current;break;default:break;}//format our new output as a string so we can display again\nreturn computation.toString();}//simple function to format our inputs. splitting the integer and decimal, and then re-stitching them is so that a X.0 doesn't get reformatted to X immediately\nfunction formatOperand(operand){if(operand==null)return;var _operand$split=operand.split('.'),_operand$split2=_slicedToArray(_operand$split,2),integer=_operand$split2[0],decimal=_operand$split2[1];if(decimal==null)return INTEGER_FORMATTER.format(integer);return\"\".concat(INTEGER_FORMATTER.format(integer),\".\").concat(decimal);}export default App;","map":{"version":3,"names":["useReducer","DigitButton","OperationButton","ACTIONS","ADD_DIGIT","CLEAR","CHOOSE_OPERATION","DELETE_DIGIT","EVALUATE","INTEGER_FORMATTER","Intl","NumberFormat","maximumFractionDigits","App","reducer","currentOperand","previousOperand","operation","dispatch","formatOperand","type","state","payload","overwrite","length","slice","digit","includes","evaluate","prev","parseFloat","current","isNaN","computation","toString","operand","split","integer","decimal","format"],"sources":["C:/Users/Nick/OneDrive/Documents/github/reactcalculator/src/App.js"],"sourcesContent":["\r\n//this is a basic calculator making use of react.\r\n//inspiration and logical choices made following https://github.com/WebDevSimplified/react-calculator/blob/main/src/App.js\r\n//comments added by me, after building; the goal in this is to show understanding of what is going on, with a separate project to create a proper react.js app\r\nimport { useReducer } from 'react';\r\nimport DigitButton from \"./DigitButton\"\r\nimport OperationButton from \"./OperationButton\"\r\nimport './App.css';\r\nexport const ACTIONS = {\r\n  ADD_DIGIT: 'add-digit',\r\n  CLEAR: 'clear',\r\n  CHOOSE_OPERATION: 'choose-operation',\r\n  DELETE_DIGIT: 'delete-digit',\r\n  EVALUATE: 'evaluate'\r\n}\r\nconst INTEGER_FORMATTER = new Intl.NumberFormat(\"en-us\", {\r\n  maximumFractionDigits: 0\r\n})\r\n//the main compiler. the return is the output of the html\r\nfunction App() {\r\n  const [{ currentOperand, previousOperand, operation }, dispatch] = useReducer(reducer, {})\r\n  return (\r\n    <div className=\"calculator-grid\">\r\n      <div className=\"output\">\r\n        <div className=\"previous-operand\">{formatOperand(previousOperand)} {operation}</div>\r\n        <div className=\"current-operand\">{formatOperand(currentOperand)}</div>\r\n      </div>\r\n      <button className=\"span-two\" onClick={() => dispatch({type: ACTIONS.CLEAR})}>AC</button>\r\n      <button onClick={() => dispatch({ type: ACTIONS.DELETE_DIGIT})}>DEL</button>\r\n      <OperationButton operation=\"รท\" dispatch={dispatch} />\r\n      <DigitButton digit=\"1\" dispatch={dispatch} />\r\n      <DigitButton digit=\"2\" dispatch={dispatch} />\r\n      <DigitButton digit=\"3\" dispatch={dispatch} />\r\n      <OperationButton operation=\"*\" dispatch={dispatch} />\r\n      <DigitButton digit=\"4\" dispatch={dispatch} />\r\n      <DigitButton digit=\"5\" dispatch={dispatch} />\r\n      <DigitButton digit=\"6\" dispatch={dispatch} />\r\n      <OperationButton operation=\"+\" dispatch={dispatch} />\r\n      <DigitButton digit=\"7\" dispatch={dispatch} />\r\n      <DigitButton digit=\"8\" dispatch={dispatch} />\r\n      <DigitButton digit=\"9\" dispatch={dispatch} />\r\n      <OperationButton operation=\"-\" dispatch={dispatch} />\r\n      <DigitButton digit=\".\" dispatch={dispatch} />\r\n      <DigitButton digit=\"0\" dispatch={dispatch} />\r\n      <button className=\"span-two\" onClick={() => dispatch({ type: ACTIONS.EVALUATE })}>=</button>\r\n    </div>\r\n  );\r\n}\r\n//this receives any button press. the main switch statement bases off of the type that is passed\r\nfunction reducer(state, {type, payload }) {\r\n  switch(type) {\r\n    case ACTIONS.DELETE_DIGIT:\r\n      //on delete, overwrite the last operand if it is populated, or the last character in our evaluation string if it exists\r\n      if (state.overwrite) {\r\n        return {\r\n          ...state,\r\n          overwrite: false,\r\n          currentOperand: null,\r\n        };\r\n      }\r\n      if (state.currentOperand == null) return state;\r\n      if (state.currentOperand.length === 1) {\r\n        return {\r\n          ...state,\r\n          currentOperand: null,\r\n        };\r\n      }\r\n      return {\r\n        ...state, \r\n        currentOperand: state.currentOperand.slice(0, -1)\r\n      };\r\n    //on add, append the digit to our evaluation string. if we want to add a decimal, and a decimal already exists, don't add it. \r\n    case ACTIONS.ADD_DIGIT:\r\n      if (state.overwrite) {\r\n        return {\r\n          ...state,\r\n          currentOperand: payload.digit,\r\n          overwrite: false,\r\n        };\r\n      }\r\n      if (payload.digit === \"0\" && state.currentOperand === \"0\") return state;\r\n      if (payload.digit === \".\" && state.currentOperand.includes(\".\")) return state;\r\n      return {\r\n        ...state,\r\n        currentOperand: `${state.currentOperand || \"\"}${payload.digit}`,\r\n      };\r\n    // simply clear our evaluation string\r\n    case ACTIONS.CLEAR:\r\n      return {};\r\n    //apply an operation to our evaluatable strings.\r\n    case ACTIONS.CHOOSE_OPERATION:\r\n      //if nothing exists yet, do nothing; return the state we started with\r\n      if (state.currentOperand == null && state.previousOperand == null) {\r\n        return state;\r\n      }\r\n      // if we already applied an operation, which is stored in previousOperand, replace the operation. we can't apply two operations on top of eachother\r\n      if (state.currentOperand == null) {\r\n        return {\r\n          ...state,\r\n          operation: payload.operation,\r\n        };\r\n      }\r\n      //if there is no previous operand, set the current operand to the previous operand and set the operation, clearing the current operand\r\n      if (state.previousOperand == null) {\r\n        return {\r\n          ...state, operation: payload.operation,\r\n          previousOperand: state.currentOperand,\r\n          currentOperand: null,\r\n        };\r\n      }\r\n      // we have a current operand, a previous operand, and an operation. evaluate it and set the overwrite so the next input takes priority\r\n      return {\r\n        ...state,\r\n        previousOperand: evaluate(state),\r\n        currentOperand: null,\r\n        operation: payload.operation,\r\n      };\r\n    // on evaluation, if we are missing a relevant section of info, do nothing.\r\n    //if we have everything, set the current main display with the evaluation function. \r\n    //overwrite is set to true, so if you input new information after evaluating, the new information takes priority.\r\n    case ACTIONS.EVALUATE:\r\n      if (\r\n        state.operation == null ||\r\n        state.currentOperand == null ||\r\n        state.previousOperand == null\r\n      ) {\r\n        return state;\r\n      }\r\n      return {\r\n        ...state,\r\n        overwrite: true,\r\n        previousOperand: null,\r\n        operation: null,\r\n        currentOperand: evaluate(state),\r\n      };\r\n    // do nothing on default, we should always have a type assigned on dispatch\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n//function which evaluates all of our inputs when we have a full math problem\r\nfunction evaluate({currentOperand, previousOperand, operation}) {\r\n  //format our information as numerals so we can do math\r\n  var prev = parseFloat(previousOperand); \r\n  var current = parseFloat(currentOperand);\r\n  if (isNaN(prev) || isNaN(current)) return \"\"\r\n  let computation = \"\";\r\n  //switch statement moves between our available mathematical operations\r\n  switch(operation) {\r\n    case \"+\":\r\n      computation = prev + current;\r\n      break;\r\n    case \"-\":\r\n      computation = prev - current;\r\n      break;\r\n    case \"*\":\r\n      computation = prev * current;\r\n      break;\r\n    case \"รท\":\r\n      computation = prev / current;\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n  //format our new output as a string so we can display again\r\n  return computation.toString();\r\n}\r\n//simple function to format our inputs. splitting the integer and decimal, and then re-stitching them is so that a X.0 doesn't get reformatted to X immediately\r\nfunction formatOperand(operand) {\r\n  if (operand == null) return;\r\n  const [integer, decimal] = operand.split('.');\r\n  if (decimal == null) return INTEGER_FORMATTER.format(integer);\r\n  return `${INTEGER_FORMATTER.format(integer)}.${decimal}`;\r\n}\r\nexport default App;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}