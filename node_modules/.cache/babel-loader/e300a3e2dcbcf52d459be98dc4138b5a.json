{"ast":null,"code":"//this is a basic calculator making use of react.\n//inspiration and logical choices made following https://github.com/WebDevSimplified/react-calculator/blob/main/src/App.js\n//comments added by me, after building; the goal in this is to show understanding of what is going on, with a separate project to create a proper react.js app\nimport{useReducer}from'react';import DigitButton from\"./DigitButton\";import OperationButton from\"./OperationButton\";import'./App.css';import{jsxs as _jsxs}from\"react/jsx-runtime\";import{jsx as _jsx}from\"react/jsx-runtime\";export const ACTIONS={ADD_DIGIT:'add-digit',CLEAR:'clear',CHOOSE_OPERATION:'choose-operation',DELETE_DIGIT:'delete-digit',EVALUATE:'evaluate'};const INTEGER_FORMATTER=new Intl.NumberFormat(\"en-us\",{maximumFractionDigits:0});//the main compiler. the return is the output of the html\nfunction App(){const[{currentOperand,previousOperand,operation},dispatch]=useReducer(reducer,{});return/*#__PURE__*/_jsxs(\"div\",{className:\"calculator-grid\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"output\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"previous-operand\",children:[formatOperand(previousOperand),\" \",operation]}),/*#__PURE__*/_jsx(\"div\",{className:\"current-operand\",children:formatOperand(currentOperand)})]}),/*#__PURE__*/_jsx(\"button\",{className:\"span-two\",onClick:()=>dispatch({type:ACTIONS.CLEAR}),children:\"AC\"}),/*#__PURE__*/_jsx(\"button\",{onClick:()=>dispatch({type:ACTIONS.DELETE_DIGIT}),children:\"DEL\"}),/*#__PURE__*/_jsx(OperationButton,{operation:\"\\xF7\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"1\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"2\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"3\",dispatch:dispatch}),/*#__PURE__*/_jsx(OperationButton,{operation:\"*\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"4\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"5\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"6\",dispatch:dispatch}),/*#__PURE__*/_jsx(OperationButton,{operation:\"+\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"7\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"8\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"9\",dispatch:dispatch}),/*#__PURE__*/_jsx(OperationButton,{operation:\"-\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\".\",dispatch:dispatch}),/*#__PURE__*/_jsx(DigitButton,{digit:\"0\",dispatch:dispatch}),/*#__PURE__*/_jsx(\"button\",{className:\"span-two\",onClick:()=>dispatch({type:ACTIONS.EVALUATE}),children:\"=\"})]});}//this receives any button press. the main switch statement bases off of the type that is passed\nfunction reducer(state,_ref){let{type,payload}=_ref;switch(type){case ACTIONS.DELETE_DIGIT://on delete, overwrite the last operand if it is populated, or the last character in our evaluation string if it exists\nif(state.overwrite){return{...state,overwrite:false,currentOperand:null};}if(state.currentOperand==null)return state;if(state.currentOperand.length===1){return{...state,currentOperand:null};}return{...state,currentOperand:state.currentOperand.slice(0,-1)};//on add, append the digit to our evaluation string. if we want to add a decimal, and a decimal already exists, don't add it. \ncase ACTIONS.ADD_DIGIT:if(state.overwrite){return{...state,currentOperand:payload.digit,overwrite:false};}if(payload.digit===\"0\"&&state.currentOperand===\"0\")return state;if(payload.digit===\".\"&&state.currentOperand.includes(\".\"))return state;return{...state,currentOperand:\"\".concat(state.currentOperand||\"\").concat(payload.digit)};// simply clear our evaluation string\ncase ACTIONS.CLEAR:return{};//apply an operation to our evaluatable strings.\ncase ACTIONS.CHOOSE_OPERATION://if nothing exists yet, do nothing; return the state we started with\nif(state.currentOperand==null&&state.previousOperand==null){return state;}// if we already applied an operation, which is stored in previousOperand, replace the operation. we can't apply two operations on top of eachother\nif(state.currentOperand==null){return{...state,operation:payload.operation};}//if there is no previous operand, set the current operand to the previous operand and set the operation, clearing the current operand\nif(state.previousOperand==null){return{...state,operation:payload.operation,previousOperand:state.currentOperand,currentOperand:null};}// we have a current operand, a previous operand, and an operation. evaluate it and set the overwrite so the next input takes priority\nreturn{...state,previousOperand:evaluate(state),currentOperand:null,operation:payload.operation};// on evaluation, if we are missing a relevant section of info, do nothing.\n//if we have everything, set the current main display with the evaluation function. \n//overwrite is set to true, so if you input new information after evaluating, the new information takes priority.\ncase ACTIONS.EVALUATE:if(state.operation==null||state.currentOperand==null||state.previousOperand==null){return state;}return{...state,overwrite:true,previousOperand:null,operation:null,currentOperand:evaluate(state)};// do nothing on default, we should always have a type assigned on dispatch\ndefault:return state;}}//function which evaluates all of our inputs when we have a full math problem\nfunction evaluate(_ref2){let{currentOperand,previousOperand,operation}=_ref2;//format our information as numerals so we can do math\nvar prev=parseFloat(previousOperand);var current=parseFloat(currentOperand);if(isNaN(prev)||isNaN(current))return\"\";let computation=\"\";//switch statement moves between our available mathematical operations\nswitch(operation){case\"+\":computation=prev+current;break;case\"-\":computation=prev-current;break;case\"*\":computation=prev*current;break;case\"รท\":computation=prev/current;break;default:break;}//format our new output as a string so we can display again\nreturn computation.toString();}//simple function to format our inputs. splitting the integer and decimal, and then re-stitching them is so that a X.0 doesn't get reformatted to X immediately\nfunction formatOperand(operand){if(operand==null)return;const[integer,decimal]=operand.split('.');if(decimal==null)return INTEGER_FORMATTER.format(integer);return\"\".concat(INTEGER_FORMATTER.format(integer),\".\").concat(decimal);}export default App;","map":{"version":3,"names":["useReducer","DigitButton","OperationButton","jsxs","_jsxs","jsx","_jsx","ACTIONS","ADD_DIGIT","CLEAR","CHOOSE_OPERATION","DELETE_DIGIT","EVALUATE","INTEGER_FORMATTER","Intl","NumberFormat","maximumFractionDigits","App","currentOperand","previousOperand","operation","dispatch","reducer","className","children","formatOperand","onClick","type","digit","state","_ref","payload","overwrite","length","slice","includes","concat","evaluate","_ref2","prev","parseFloat","current","isNaN","computation","toString","operand","integer","decimal","split","format"],"sources":["C:/Users/Nick/OneDrive/Documents/github/reactcalculator/src/App.js"],"sourcesContent":["\r\n//this is a basic calculator making use of react.\r\n//inspiration and logical choices made following https://github.com/WebDevSimplified/react-calculator/blob/main/src/App.js\r\n//comments added by me, after building; the goal in this is to show understanding of what is going on, with a separate project to create a proper react.js app\r\nimport { useReducer } from 'react';\r\nimport DigitButton from \"./DigitButton\"\r\nimport OperationButton from \"./OperationButton\"\r\nimport './App.css';\r\nexport const ACTIONS = {\r\n  ADD_DIGIT: 'add-digit',\r\n  CLEAR: 'clear',\r\n  CHOOSE_OPERATION: 'choose-operation',\r\n  DELETE_DIGIT: 'delete-digit',\r\n  EVALUATE: 'evaluate'\r\n}\r\nconst INTEGER_FORMATTER = new Intl.NumberFormat(\"en-us\", {\r\n  maximumFractionDigits: 0\r\n})\r\n//the main compiler. the return is the output of the html\r\nfunction App() {\r\n  const [{ currentOperand, previousOperand, operation }, dispatch] = useReducer(reducer, {})\r\n  return (\r\n    <div className=\"calculator-grid\">\r\n      <div className=\"output\">\r\n        <div className=\"previous-operand\">{formatOperand(previousOperand)} {operation}</div>\r\n        <div className=\"current-operand\">{formatOperand(currentOperand)}</div>\r\n      </div>\r\n      <button className=\"span-two\" onClick={() => dispatch({type: ACTIONS.CLEAR})}>AC</button>\r\n      <button onClick={() => dispatch({ type: ACTIONS.DELETE_DIGIT})}>DEL</button>\r\n      <OperationButton operation=\"รท\" dispatch={dispatch} />\r\n      <DigitButton digit=\"1\" dispatch={dispatch} />\r\n      <DigitButton digit=\"2\" dispatch={dispatch} />\r\n      <DigitButton digit=\"3\" dispatch={dispatch} />\r\n      <OperationButton operation=\"*\" dispatch={dispatch} />\r\n      <DigitButton digit=\"4\" dispatch={dispatch} />\r\n      <DigitButton digit=\"5\" dispatch={dispatch} />\r\n      <DigitButton digit=\"6\" dispatch={dispatch} />\r\n      <OperationButton operation=\"+\" dispatch={dispatch} />\r\n      <DigitButton digit=\"7\" dispatch={dispatch} />\r\n      <DigitButton digit=\"8\" dispatch={dispatch} />\r\n      <DigitButton digit=\"9\" dispatch={dispatch} />\r\n      <OperationButton operation=\"-\" dispatch={dispatch} />\r\n      <DigitButton digit=\".\" dispatch={dispatch} />\r\n      <DigitButton digit=\"0\" dispatch={dispatch} />\r\n      <button className=\"span-two\" onClick={() => dispatch({ type: ACTIONS.EVALUATE })}>=</button>\r\n    </div>\r\n  );\r\n}\r\n//this receives any button press. the main switch statement bases off of the type that is passed\r\nfunction reducer(state, {type, payload }) {\r\n  switch(type) {\r\n    case ACTIONS.DELETE_DIGIT:\r\n      //on delete, overwrite the last operand if it is populated, or the last character in our evaluation string if it exists\r\n      if (state.overwrite) {\r\n        return {\r\n          ...state,\r\n          overwrite: false,\r\n          currentOperand: null,\r\n        };\r\n      }\r\n      if (state.currentOperand == null) return state;\r\n      if (state.currentOperand.length === 1) {\r\n        return {\r\n          ...state,\r\n          currentOperand: null,\r\n        };\r\n      }\r\n      return {\r\n        ...state, \r\n        currentOperand: state.currentOperand.slice(0, -1)\r\n      };\r\n    //on add, append the digit to our evaluation string. if we want to add a decimal, and a decimal already exists, don't add it. \r\n    case ACTIONS.ADD_DIGIT:\r\n      if (state.overwrite) {\r\n        return {\r\n          ...state,\r\n          currentOperand: payload.digit,\r\n          overwrite: false,\r\n        };\r\n      }\r\n      if (payload.digit === \"0\" && state.currentOperand === \"0\") return state;\r\n      if (payload.digit === \".\" && state.currentOperand.includes(\".\")) return state;\r\n      return {\r\n        ...state,\r\n        currentOperand: `${state.currentOperand || \"\"}${payload.digit}`,\r\n      };\r\n    // simply clear our evaluation string\r\n    case ACTIONS.CLEAR:\r\n      return {};\r\n    //apply an operation to our evaluatable strings.\r\n    case ACTIONS.CHOOSE_OPERATION:\r\n      //if nothing exists yet, do nothing; return the state we started with\r\n      if (state.currentOperand == null && state.previousOperand == null) {\r\n        return state;\r\n      }\r\n      // if we already applied an operation, which is stored in previousOperand, replace the operation. we can't apply two operations on top of eachother\r\n      if (state.currentOperand == null) {\r\n        return {\r\n          ...state,\r\n          operation: payload.operation,\r\n        };\r\n      }\r\n      //if there is no previous operand, set the current operand to the previous operand and set the operation, clearing the current operand\r\n      if (state.previousOperand == null) {\r\n        return {\r\n          ...state, operation: payload.operation,\r\n          previousOperand: state.currentOperand,\r\n          currentOperand: null,\r\n        };\r\n      }\r\n      // we have a current operand, a previous operand, and an operation. evaluate it and set the overwrite so the next input takes priority\r\n      return {\r\n        ...state,\r\n        previousOperand: evaluate(state),\r\n        currentOperand: null,\r\n        operation: payload.operation,\r\n      };\r\n    // on evaluation, if we are missing a relevant section of info, do nothing.\r\n    //if we have everything, set the current main display with the evaluation function. \r\n    //overwrite is set to true, so if you input new information after evaluating, the new information takes priority.\r\n    case ACTIONS.EVALUATE:\r\n      if (\r\n        state.operation == null ||\r\n        state.currentOperand == null ||\r\n        state.previousOperand == null\r\n      ) {\r\n        return state;\r\n      }\r\n      return {\r\n        ...state,\r\n        overwrite: true,\r\n        previousOperand: null,\r\n        operation: null,\r\n        currentOperand: evaluate(state),\r\n      };\r\n    // do nothing on default, we should always have a type assigned on dispatch\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n//function which evaluates all of our inputs when we have a full math problem\r\nfunction evaluate({currentOperand, previousOperand, operation}) {\r\n  //format our information as numerals so we can do math\r\n  var prev = parseFloat(previousOperand); \r\n  var current = parseFloat(currentOperand);\r\n  if (isNaN(prev) || isNaN(current)) return \"\"\r\n  let computation = \"\";\r\n  //switch statement moves between our available mathematical operations\r\n  switch(operation) {\r\n    case \"+\":\r\n      computation = prev + current;\r\n      break;\r\n    case \"-\":\r\n      computation = prev - current;\r\n      break;\r\n    case \"*\":\r\n      computation = prev * current;\r\n      break;\r\n    case \"รท\":\r\n      computation = prev / current;\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n  //format our new output as a string so we can display again\r\n  return computation.toString();\r\n}\r\n//simple function to format our inputs. splitting the integer and decimal, and then re-stitching them is so that a X.0 doesn't get reformatted to X immediately\r\nfunction formatOperand(operand) {\r\n  if (operand == null) return;\r\n  const [integer, decimal] = operand.split('.');\r\n  if (decimal == null) return INTEGER_FORMATTER.format(integer);\r\n  return `${INTEGER_FORMATTER.format(integer)}.${decimal}`;\r\n}\r\nexport default App;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}